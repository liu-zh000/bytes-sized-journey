# 学习笔记



1.编译四步骤：编译预处理、编译、汇编、链接

2.数据类型大小
![alt text](image-1.png)
C语言设计原则是??高效利用硬件??，因此类型大小由编译器根据目标硬件决定（只要满足标准的最小范围）。

           16位操作系统：long：4字节，int：2字节
           32位操作系统：long：4字节，int：4字节
           64位操作系统：long：8字节，int：4字节

3.I2C、SPI、UART区别：

并行/串行
异步串行/同步串行：同步通信有时钟，异步通信有起始位
单工（广播、显示器接口、遥控器）/半双工（I2C）/全双工（电话、网口、UART）
![alt text](image-2.png)
?   ?TTL、RS232、RS485??都是基于UART协议，只是物理电平不同。UART本身是协议，而TTL、RS232、RS485是电平标准。
?   ?同步通信??需要时钟线，因此速度通常可以做得更高；??异步通信??不需要时钟线，但需要双方约定波特率（可能存在微小误差，故高速时对时钟精度要求高）。
?   ?串行通信??虽然速度在理论上低于并行通信，但由于抗干扰能力强、布线简单、成本低，已成为远距离通信的主流。
![alt text](image-3.png)
![alt text](image-4.png)

```cpp
{
    #include <cmath>
    double result = pow(10, i);  // 返回 double 
    int intResult = static\_cast\<int>(pow(10, i));  // 强制转换
}
```
2.字符数字转换
![alt text](image.png)
```cpp

    string num1;
    `num1[i] - '0'`
```
3.c++静态成员函数
![alt text](image-5.png)


![alt text](image-7.png)


4、tcp udp 区别
| **特性**                  | TCP（传输控制协议）                                     | UDP（用户数据报协议）                               |
|---------------------------|---------------------------------------------------------|-----------------------------------------------------|
| **连接方式**              | 面向连接（Connection-Oriented）                         | 无连接（Connectionless）                             |
| **可靠性保证**            | ? 确保数据完整、有序、无丢失<br>（自动重传丢失数据包） | ? 不保证可靠性<br>（可能丢失/乱序/重复）           |
| **连接建立/断开过程**     | 需要三次握手（SYN-SYN/ACK-ACK）<br>四次挥手（FIN-ACK） | 无连接建立/断开过程                                 |
| **流量控制机制**          | ? 滑动窗口协议<br>（动态调整发送速率）                 | ? 无流量控制                                       |
| **拥塞控制机制**          | ? 慢启动、拥塞避免、快恢复<br>（根据网络状态动态调节） | ? 无拥塞控制                                       |
| **传输速度**              | 较慢（建立连接+额外控制开销）                           | **极快**（无连接开销+最小头部）                     |
| **数据边界**              | 字节流（Byte Stream）<br>可能"粘包"需应用层处理边界     | 数据报文（Datagram）<br>保留发送时消息边界          |
| **数据包结构**            | **复杂包头**<br>（20-60字节，含序列号/ACK号/窗口大小等） | **简单包头**<br>（固定8字节，仅端口号+长度+校验和） |
| **错误检测**              | ? 校验和检测数据损坏<br>自动修复（重传机制）           | ? 校验和检测数据损坏<br>但丢弃损坏包不修复         |
| **数据顺序**              | ? 保证数据按发送顺序到达                               | ? 不保证顺序（可能乱序到达）                       |
| **通信模式**              | 仅支持1:1单播通信                                      | 支持单播、多播、广播<br>（1:1，1:N，N:N）           |
| **头部开销占比**          | 较高（通常占数据包的5-20%）                             | 极低（通常小于5%）                                 |
| **适用场景**              | Web浏览（HTTP/HTTPS）<br>文件传输（FTP/SFTP）<br>电子邮件（SMTP）<br>数据库访问 | 实时视频/语音<br>在线游戏<br>DNS查询<br>直播流媒体<br>IoT传感器 |
| **内核资源占用**          | 高（维护连接状态表/重传缓冲区）                         | 极低（无状态连接）                                  |

### new/delete vs malloc/free 对比

| **特性**                | **`new`/`delete`**                                    | **`malloc()`/`free()`**                              |
|-------------------------|------------------------------------------------------|------------------------------------------------------|
| **语言范畴**            | C++运算符                                            | C标准库函数                                          |
| **语法**                | `Type* ptr = new Type;`<br>`delete ptr;`             | `void* ptr = malloc(size);`<br>`free(ptr);`          |
| **构造函数调用**        | ? 调用构造函数                                      | ? 不调用构造函数                                    |
| **析构函数调用**        | ? 调用析构函数                                      | ? 不调用析构函数                                    |
| **返回类型**            | 强类型指针 (`Type*`)                                 | 无类型指针 (`void*`)，需显式转型                    |
| **内存大小计算**        | 自动计算：`new Type`                                 | 手动计算：`malloc(sizeof(Type)*n)`                  |
| **分配失败处理**        | 抛出 `std::bad_alloc` 异常                           | 返回 `NULL`                                          |
| **重载能力**            | ? 可全局/类内重载                                   | ? 不可重载                                          |
| **内存来源**            | 自由存储区 (可能≠堆)                                 | 堆内存                                               |
| **数组支持**            | `new Type[n]`/`delete[]`                             | `malloc(n*sizeof)`/`free` 无特殊数组处理            |
| **类型安全**            | ? 类型安全                                          | ? 类型不安全                                        |
| **重新分配**            | ? 不支持 (`realloc`替代方案)                        | ? 支持 `realloc`                                    |
| **多态支持**            | ? 正确调用派生类析构                                | ? 破坏对象完整性                                    |
| **自定义对齐**          | C++11起支持 `alignas`                                | 需平台相关函数 (`posix_memalign`等)                 |
| **初始化**              | `new Type(args)`/`new Type{values}`                 | 需额外 `memset` 或手动赋值                          |
| **异常安全**            | ? 可与异常机制集成                                  | ? 需手动检查返回值                                  |
| **代码风格**            | C++面向对象风格                                      | C过程式风格                                        a |
| **底层内存操作**        | ? 不适合原始内存操作                                | ? 适合原始内存分配                                 |